多态

父类或接口中的方法被 private / final修饰，子类/实现类不能重写

 

多态调用中,编译看谁,运行看谁

\* 编译都看 = 左边的父类, 父类有编译成功,父类没有编译失败

\* 运行,静态方法, 运行父类中的静态方法 static

\* 运行,非静态方法,运行子类的重写方法

\* 成员变量,编译运行全是父类

原因: 静态属于类,不属于对象

对象的多态性,静态和对象无关,父类的引用.静态方法

例：parent{static eat()}

Child{static eat()}

Parent P=new child();

P.eat()就是调用父类自有的

14:07

 

>  
>
> 多态：
>
>  
>
> 1.概述:一个事物有不同的形态
>
> 2.条件:
>
> a.子父类继承关系(接口,实现关系)
>
> b.必须有方法的重写
>
> c.父类引用指向子类对象\--\>父类 对象名 = new 子类()
>
> 3.注意:
>
> a.只能调用重写的方法
>
> b.不能调用子类特有的方法\--\>弊端
>
> c.多态的好处不能体现在new对象上,它的好处体现在方法的参数传递上
>
>  
>
>  
>
> [特点]{.mark}

-   多态成员变量

> 当子父类中出现同名的成员变量时，多态调用该变量时：
>
> 编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
>
> 运行时期：也是调用引用型变量所属的类中的成员变量。
>
> 简单记：编译和运行都参考等号的左边。编译运行看左边。
>
>  

-   多态成员方法

> 编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。
>
> 运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。
>
> 简而言之：编译看左边，运行看右边。
>
>  
>
>  
>
> 继承与多态总结：
>
>  
>
> **1.成员变量:**
>
> **看等号左边是谁,先调用谁**
>
> **2.成员方法:**
>
> **看new的是谁,先调用谁.子类没有,找父类**
>
>  
>
>  
>
>  

![](038_多态_000.png)
