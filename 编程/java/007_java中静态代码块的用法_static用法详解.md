[java中静态代码块的用法 static用法详解](https://www.cnblogs.com/GarfieldEr007/p/7191116.html)

2018年9月12日

10:22

（一）java 静态代码块 静态方法区别

一般情况下,如果有些代码必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的;需要在项目启动的时候就初始化,在不创建对象的情况下,其他程序来调用的时候,需要使用静态方法,这种代码是被动执行的. 静态方法在类加载的时候 就已经加载 可以用类名直接调用

比如main方法就必须是静态的 这是程序入口

两者的区别就是:静态代码块是自动执行的;

静态方法是被调用的时候才执行的.

静态方法

（1）在Java里，可以定义一个不需要创建对象的方法，这种方法就是静态方法。要实现这样的效果，只需要在类中定义的方法前加上static关键字。例如：

public static int maximum(int n1,int n2)

使用类的静态方法时，注意：

a在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。

b 静态方法不能以任何方式引用this和super关键字，因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。

（2）静态变量是属于整个类的变量而不是属于某个对象的。注意不能把任何方法体内的变量声明为静态，例如：

fun()

{

static int i=0;//非法。

}

（3）一个类可以使用不包含在任何方法体中的静态代码块，当类被载入时，静态代码块被执行，且只被执行一次，静态块常用来执行类属性的初始化。例如：

static

{

}

类装载步骤

在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，其中链接又可以分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的，各个步骤的主要工作如下：

装载：查找和导入类或接口的二进制数据；

链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；

校验：检查导入类或接口的二进制数据的正确性；

准备：给类的静态变量分配并初始化存储空间；

解析：将符号引用转成直接引用；

初始化：激活类的静态变量的初始化Java代码和静态Java代码块。

初始化类中属性是静态代码块的常用用途，但只能使用一次。

（二）静态代码块的初始化顺序  
```java
<td><p> class Parent{ </p>
<p>static String name = "hello"; </p>
<p>{ </p>
<p>System.out.println("parent block"); </p>
<p>} </p>
<p>static { </p>
<p>System.out.println("parent static block"); </p>
<p>} </p>
<p>public Parent(){ </p>
<p>System.out.println("parent constructor"); </p>
<p>} </p>
<p>} </p>
<p> </p>
<p>class Child extends Parent{ </p>
<p>static String childName = "hello"; </p>
<p>{ </p>
<p>System.out.println("child block"); </p>
<p>} </p>
<p>static { </p>
<p>System.out.println("child static block"); </p>
<p>} </p>
<p>public Child(){ </p>
<p>System.out.println("child constructor"); </p>
<p>} </p>
<p>} </p>
<p> </p>
<p>public class StaticIniBlockOrderTest { </p>
<p> </p>
<p>public static void main(String[] args) { </p>
<p>new Child();//语句(*) </p>
<p>} </p>
<p>}</p></td>
</tr>
</tbody>
</table>
```

问题：当执行完语句(\*)时，打印结果是什么顺序？为什么？

解答：当执行完语句(\*)时，打印结果是这样一个顺序 :
```java
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p> parent static block</p>
<p>child static block</p>
<p>parent block</p>
<p>parent constructor</p>
<p>child block</p>
<p>child constructor</p></td>
</tr>
</tbody>
</table>
```

分析:当执行new Child()时，它首先去看父类里面有没有静态代码块，如果有，它先去执行父类里面静态代码块里面的内容，当父类的静态代码块里面的内容执行完毕之后，接着去执行子类(自己这个类)里面的静态代码块，当子类的静态代码块执行完毕之后，它接着又去看父类有没有非静态代码块，如果有就执行父类的非静态代码块，父类的非静态代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有非静态代码块，如果有就执行子类的非静态代码块。子类的非静态代码块执行完毕再去执行子类的构造方法，这个就是一个对象的初始化顺序。

总结:

对象的初始化顺序:首先执行父类静态的内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有非静态代码块，如果有就执行父类的非静态代码块，父类的非静态代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有非静态代码块，如果有就执行子类的非静态代码块。子类的非静态代码块执行完毕再去执行子类的构造方法。总之一句话，静态代码块内容先执行，接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法。

注意:子类的构造方法，不管这个构造方法带不带参数，默认的它都会先去寻找父类的不带参数的构造方法。如果父类没有不带参数的构造方法，那么子类必须用supper关键子来调用父类带参数的构造方法，否则编译不能通过。

来自 \<<https://www.cnblogs.com/GarfieldEr007/archive/2017/07/16/7191116.html>\>
