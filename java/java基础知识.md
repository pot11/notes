ArrayList和LinekdList的插入和访问的时间复杂度  

1.ArrayList是线性表（动态数组），LinkedList是链表  
2.get,set方法，方法参数有指定位置数值的，ArrayList要优于LinkedList，因为，ArrayList有下  标，LinkedList要移动指针。  
3.新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList需要移动数据  



**关键：插入和删除是否受到元素位置的影响**
操作|ArrayList|LinkedList  
---|---|---  
添加add(E)|直接尾部添加，复杂度O(1)|复杂度O(1)
指定位置添加add(index, E)|查询后添加，插入位置后面的元素要向后移动一个单位复杂度O(n-i)|复杂度O(1)
删除remove(E)|删除指定元素，后面的元素需要逐个一定，复杂度O(n-i)|复杂度O(1)
读取get()|根据下表直接查询，复杂度O(1)|遍历获取，复杂度O(n)
(此表格未验证，不一定正确)

----------------------------
时间复杂度：  
- https://www.jianshu.com/p/3c22f82f0765   此文章错误
- https://blog.csdn.net/zhelong19830726/article/details/101062242 此文章错误

解释：  https://bbs.csdn.net/topics/220073283
```	
这个很容易就能明白的，你首先要搞清楚arraylist是用数组来实现的
linkedlist是用链表来实现的，
linkedlist插入元素快是只随便插入第n的元素，，
而你用的插入是用
 for(int n=0;n <30000;n++){ 
     linkedlist.add(n,null); 
   }  
其实是n到30000遍历呀，，书上不是上说数组的遍历要比链表的快呀，，
不知道你明白了没，，
你本意是要说随便插入个元素 linkedlist要比arraylist快，
而你的代码做的却是数组的遍历，，当然arraylist快了
```  
-------------------


数组在内存中存储是一段连续的存储区域.

数组可以通过下标,随机访问数组中的元素.

原理:
通过硬件内存管理器,通过访问数组中的下标来访问内存中存储的元素.
访问任何一个位置的数组元素,时间复杂度是O(1),硬件可以保证.

总结：  
数组  
|操作|时间复杂度|   
|--|--|
删除与添加|O(n)
随机读取|O(1)

链表  
操作|时间复杂度
|--|--|
删除与添加|O(1)
随机读取|O(n)

------------------------




合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。

合成(Gomposition，也有翻译成组合)和聚合(Aggregation)都是关联的特殊种类。聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。

合成/聚合复用原则的好处是：优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。



参考文章：
   - https://bbs.csdn.net/topics/220073283