# 杭州微蚁

## 提问  

1. 主要技术栈？微服务几个模块？
2. 消息中间件用的什么？在项目中用的什么地方？有没有通过mq发消息给其他模块吗？积分产生变动不会发消息吗？
3. redis用在什么场景？
4. 讲解交互？
5. 爬取抖音数据定时任务怎么做的？明天全量更新？定时任务间隔多少？9点跑用户量大的情况怎么办？账户不活跃了爬取也没有意义？
6. 项目多少服务器？怎么部署的？
7. 项目你觉得这么拆分？让你拆分你会怎么拆分呢？一个模块一个数据库吗？
8. java集合有哪些东西？
9. 线程安全的集合？concrrentHashMap的介绍？concrrentHashMap怎么设计原理（源码分析）？
10. java的IO流？NEW IO/BIO区别？
    1. 字符流 字节流 输入流 输出流 缓冲流
    2. 为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ）
    3. 当应用程序发起 I/O 调用后，会经历两个步骤：
       1. 内核等待 I/O 设备准备好数据
       2. 内核将数据从内核空间拷贝到用户空间。
    4. BIO（Blocking I/O）阻塞IO
    5. NIO（(Non-blocking/New I/O)）非阻塞IO
       1. 面向缓冲的，基于通道的 I/O 操作方法。适用于负载、高并发的（网络）应用
       2. 
    6. AIO NIO2
11. 注解是什么？自己有使用注解使用一些场景吗？
12. java并发编程有了解吗？并发包下面有什么东西？里面的源码有了解过吗？
13. 用到里面的锁？synicond的锁是怎么用的吗？retrendlock？可重用锁的源码有没有看过？lock和synicond区别？
14. redis主要用的？分布式锁有用到过吗？是你设计的吗？用的组件redission？
15. 线上内存飙高如何定位？什么情况下会导致内存飙高？怎么判断这个内存飙高是正常还是异常的？怎么前期分析这个东西？fullgc如何才能发现是有问题的？
    1. 线上内存飙高如何定位？定位线上内存飙高问题需要结合工具、日志和监控数据  
       1. **基础监控工具**：
          - `top` / `htop`：快速定位高内存占用的进程。
          - `jstat -gc <pid>`：观察JVM内存分代（Eden/Survivor/Old）使用率和GC次数/耗时。
          - `jmap -heap <pid>`：查看堆内存分配情况。
       2. **生成堆转储（Heap Dump）**：
          - `jmap -dump:format=b,file=heap.hprof <pid>`：手动生成堆转储。
          - 或通过JVM参数 `-XX:+HeapDumpOnOutOfMemoryError` 自动生成。
       3. **分析堆转储**：
          - 使用 **MAT（Memory Analyzer Tool）** 或 **JVisualVM** 分析：
            - 查找 **Dominator Tree** 或 **Retained Size** 最大的对象。
            - 检查 **Unreachable Objects** 判断是否内存泄漏。
       4. **线程分析**：
          - `jstack <pid>`：导出线程栈，检查是否有线程死锁或阻塞。
          - **Arthas** 的 `thread` 命令：快速定位高CPU或阻塞线程。
       5. **GC日志分析**：
          - 启用JVM参数 `-Xloggc:/path/to/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps`。
          - 观察 **Full GC频率**、**耗时** 和 **内存回收效率**（如回收后Old区内存是否显著下降）
    2. 内存飙高的常见原因
       1. **内存泄漏（Memory Leak）（对象没被回收）**：
          - 静态集合（如 `static HashMap`）长期持有对象。
          - 未关闭的资源（数据库连接、文件流）。
          - 监听器（Listener）未注销。
       2. **大对象/缓存滥用**：
          - 一次性加载超大文件到内存。
          - 本地缓存（如Guava Cache）未设置过期或大小限制。
       3. **代码问题**：
          - 死循环中持续创建对象。
          - 不合理的递归调用导致栈溢出。
       4. **JVM参数不合理**：
          - `-Xmx` 设置过小，频繁触发Full GC。
          - 新生代（Young区）过小，导致对象过早晋升到Old区。
       5. **外部依赖问题**：
          - 数据库查询未分页，返回海量数据。
          - 第三方API返回异常大报文。
    3. 判断内存飙高是否正常
       1. **结合业务场景**：
             - 正常情况：大促期间流量激增、批量任务处理。
             - 异常情况：非高峰时段内存持续增长、无业务变化时内存突增。
       2. **监控基线对比**：
             - 对比历史同期内存使用曲线，判断是否超出合理范围。
             - 观察内存是否周期性波动（如Full GC后下降）。
       3. **GC效率验证**：
             - 正常：Full GC后Old区内存下降明显（如从80%降到20%）。
             - 异常：Full GC后内存回收率低（如从95%降到90%），可能内存泄漏
    4. Full GC问题的定位方法
       1. **Full GC触发条件**：
          - Old区空间不足。
          - Metaspace（元空间）不足。
          - System.gc() 被显式调用。
       2.  **判断Full GC是否异常**：
          - **频率异常**：如每分钟多次Full GC（正常系统可能几小时一次）。
          - **耗时过长**：Full GC单次耗时 >1秒（影响系统吞吐量）。
          - **回收效率低**：Full GC后Old区内存下降不明显（如仅下降5%）。
       3.  **诊断步骤**：
          - 检查GC日志，确认Full GC原因（如 `Allocation Failure` 或 `Metadata GC Threshold`）。
          - 使用 `jstat -gcutil <pid> 1000` 实时观察内存变化。
          - 若Metaspace不足，检查是否有类加载泄漏（如动态生成类未卸载）
16. cpu飙高怎么处理？
17. 出现了问题，还是没有从jvm原理上分析？
18. 假如项目变的很快大？不止奖励积分，要扩展奖励类型（虚拟产品、实物）？要怎么设计这个模块？如何抽象设计？已经写了，以后重构会用到什么设计模式？

## 总结

1. 语气坚定执行一点，不要断断续续，唯唯诺诺。
2. 不会的问题，直接跳过不要想，会给人留下不好印象
3.
