# rabbittMQ 问题

1. 使用场景？
   1. 异步发送验证码
   2. msql与elk之间数据同步
   3. 消峰解耦
   4. **分布式事务**
2. 如何保证消息不丢失？
   - 生产者未到交换机或队列
     - publisher confirm机制，若交换机接收到会给ack回执消息，不成功
       - 生产者到交换机失败  nack publish-confirn
       - 交换机到队列失败  ack publish- return
     - 消费失败后如何处理？
       - 回调方法重发
       - 记录日志中
       - 保持数据库中定时重发，成功发送删除表中数据
       - 人工处理
   - **队列丢失消息**
     - mq内存存储，持久化到磁盘
       - 持久化交换、队列、消息
   - 消费者和队列之间
     - 消费者确认机制，成功后给mq发送ack回执消息，mq收到后回删除
     - srpingamqp三种模式
       - 手动
       - 自动：spring listener 成功ack，异常nack
       - none：全部认为是成功消费了
     - 生产中：自动auto模式，设置retry重试次数，三次后还不行，把消息放到异常队error.drict交换机中，人工处理
3. 消息重复消费问题？
    - 原因：
      - 网络抖动
      - 消费者挂了
    - 解决：
      - **消息设置唯一标识id**：支付id、文章id、订单id
      - 幂等方法：分布式锁、数据库索（悲观、乐观锁）（性能差）
4. 保证消息的顺序性？
   - 单一队列对应单一消费者（mq队列默认先进性出）
   - 服务端收到消息后设置缓存取，使用id或者根据时间进行逻辑重排
5. 死信交换机？（延迟队列了解吗？）
    - 延迟队列：队列中的消息会被延时消费
      - 场景：超时订单、限时优惠、定时发布
      - 延迟队列 == 死信交换机 + ttl(存活时间)
    - 死信交换机：
      - 条件：
        - 消费者使用basic.refect或basci.nack,且消息requeue参赛设置false
        - 队列满了，最早的消息会变成死信
        - **超时无人消费**
      - 处理：普通队列绑定，设置dead-letter-exchange属性的死信交换机，死信交换机router key绑定一个死信队列
    - TTL time to live
       - 队列设置存活时间
       - 消息设置存活时间
    - delayexchange插件简化开发  
6. rebbtiemq100万数据消息堆积怎么解决？
    - 概念：生产者生产速度 》消费者消费速度，消息堆积导致队列上限已满，多出来的消息成为死信或丢弃
    - 解决：
      - 增加mq机器
      - 增加消费者，提高消费速度
        - 排查出问题，然后把新包快速部署到多台服务器上，快速消费积压消息
        - 消费者用多线程处理
      - 扩大队列容积：使用惰性队列
        - 设置队列属性x-queue-model为lazy
        - 磁盘存储，消息上限高
        - 性能稳定，但磁盘io，消息时效性低
